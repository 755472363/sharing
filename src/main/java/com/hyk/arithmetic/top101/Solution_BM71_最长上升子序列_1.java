package com.hyk.arithmetic.top101;

import java.util.Arrays;

/**
 * BM71 最长上升子序列(一)
 */
public class Solution_BM71_最长上升子序列_1 {

    /**
     * 给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。
     * 所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。
     * 我们定义一个序列是 严格上升 的，当且仅当该序列不存在两个下标 i 和 j 满足 i<j 且  arr_i ≥ arr_j
     * 数据范围：0≤n≤1000
     * 要求：时间复杂度 O(n^2)， 空间复杂度 O(n)
     *
     * 示例1
     * 输入：[6,3,1,5,2,3,7]
     * 返回值：4
     * 说明：该数组最长上升子序列为 [1,2,3,7] ，长度为4
     */

    /**
     * 方法：动态规划（推荐使用）
     * 思路：
     * 要找到最长的递增子序列长度，每当我们找到一个位置，它是继续递增的子序列还是不是，它选择前面哪一处接着才能达到最长的递增子序列，这类有状态转移的问题常用方法是动态规划。
     * <p>
     * 具体做法：
     * step 1：用dp[i]表示到元素i结尾时，最长的子序列的长度，初始化为1，因为只有数组有元素，至少有一个算是递增。
     * step 2：第一层遍历数组每个位置，得到n个长度的子数组。
     * step 3：第二层遍历相应子数组求对应到元素i结尾时的最长递增序列长度，期间维护最大值。
     * step 4：对于每一个到i结尾的子数组，如果遍历过程中遇到元素j小于结尾元素，说明以该元素结尾的子序列加上子数组末尾元素也是严格递增的，因此转移方程为dp[i]=dp[j]+1。
     */

    // 有点不好理解
    public int LIS(int[] arr) {
        if (arr == null || arr.length < 1) return 0;
        // dp[i] 表示i位置最长严格上升子序列长度；
        int[] dp = new int[arr.length];
        // 初始化为1，因为只有数组有元素，至少有一个算是递增
        Arrays.fill(dp, 1);
        int res = 0;
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                //可能j不是所需要的最大的，因此需要dp[i] < dp[j] + 1
                if (arr[i] > arr[j] && dp[i] < dp[j] + 1) { // 不太好理解
                    //i点比j点大，理论上dp要加1
                    dp[i] = dp[j] + 1;
                    //找到最大长度
                    res = Math.max(res, dp[i]);
                }
            }
        }
        return res;
    }

    /**
     * arr 6, 3, 1, 5, 2, 3, 7
     * dp  1, 1, 1, 2, 2, 3, 4
     * dp  1, 1, 1, 1, 1, 1, 1 （默认）
     */
    public static void main(String[] args) {
        int[] arr = {6, 3, 1, 5, 2, 3, 7};
        int res1 = new Solution_BM71_最长上升子序列_1().LIS(arr);
        // 4
        System.out.println("res1 = " + res1);
    }

}



