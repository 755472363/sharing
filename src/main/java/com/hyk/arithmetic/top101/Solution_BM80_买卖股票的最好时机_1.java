package com.hyk.arithmetic.top101;

/**
 * BM80 买卖股票的最好时机(一)
 */
public class Solution_BM80_买卖股票的最好时机_1 {

    /**
     * 描述
     * 假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益
     * 1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天
     * 2.如果不能获取到任何利润，请返回0
     * 3.假设买入卖出均无手续费
     *
     * 数据范围： 0 ≤ n ≤ 10^5 ,0 ≤ val ≤ 10^4
     * 要求：空间复杂度 O(1),时间复杂度 O(n)
     *
     * 示例1
     * 输入：[8,9,2,5,4,7,1]
     * 返回值：5
     * 说明：在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，
     * 不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。
     */


    /**
     * 贪心（扩展思路）
     * 思路：
     * 如果我们在某一天卖出了股票，那么要想收益最高，一定是它前面价格最低的那天买入的股票才可以。
     * 因此我们可以利用贪心思想解决，每次都将每日收入与最低价格相减维护最大值。
     *
     * 具体做法：
     * step 1：首先排除数组为空的特殊情况。
     * step 2：将第一天看成价格最低，后续遍历的时候遇到价格更低则更新价格最低。
     * step 3：每次都比较最大收益与当日价格减去价格最低的值，选取最大值作为最大收益。
     * 空间复杂度 O(1)，时间复杂度 O(n)
     */

    /**
     * 就是求数组从左到右，正向到最大差值
     * 空间复杂度 O(1)，时间复杂度 O(n)
     */
    public int maxProfit(int[] prices) {
        if (prices.length <= 1) return 0;
        // 遍历数组到i时的最小值，初始值prices[0]
        int min = prices[0];
        // 最大收益 = max(当前最大收益，当前值-最小值min)
        int max = 0;
        for (int i = 1; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            max = Math.max(prices[i] - min, max);
        }
        return max;
    }

    /**
     *
     */
    public static void main(String[] args) {
        int[] arr = {8, 9, 2, 5, 4, 7, 1};
        int res1 = new Solution_BM80_买卖股票的最好时机_1().maxProfit(arr);
        // 5
        System.out.println("res1 = " + res1);
    }

}



