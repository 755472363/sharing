package com.hyk.arithmetic;

import java.util.Arrays;

/**
 * NC91 最长上升子序列(三)
 */
public class Solution_NC91_最长上升子序列_3 {

    /**
     * 给定数组 arr ，设长度为 n ，输出 arr 的最长上升子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）
     *
     * 数据范围：0 ≤ n ≤ 200000,  0 ≤ arr_i ≤1000000000
     * 要求：空间复杂度 O(n)，时间复杂度 O(nlogn)
     *
     *示例2
     * 输入：[1,2,8,6,4]
     * 返回值：[1,2,4]
     * 说明：其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4）
     */

    /**
     * 方法一：动态规划（超时）
     * 定义dp[i]为对前 i 个数中，以第 i 个数字结尾的最长上升子序列的长度，且arr[i]必须被选取。
     * 分析知最大上升序列需要满足arr[i] > arr[j] , 其中i>j 。
     * 对dp[i]，可以由在i之前且满足arr[i] > arr[j]的状态转移得到
     * 可得状态转移方程为：dp[i] = mac(dp[j])+1,其中0<=j<=i ，且 arr[j] < arr[i] .
     * 在dp[i]计算完成后，为了得到最长递增子序列，需要从后往前对dp数组进行一次遍历，找到符合条件的数填入答案中。
     * 由于dp[i]的值绝对能在左侧找到更小值dp[j],故只需要选取第一次遇见的满足条件的数即可
     */
    public int[] LIS(int[] arr) {
        int[] dp = new int[arr.length];
        Arrays.fill(dp, 1);
        int maxLength = 0, n = arr.length;
        for (int i = 0; i < n; i++) {
            //找到满足 j < i,arr[j] < arr[i],的最大dp[j]进行转移
            int res = 0;
            for (int j = 0; j < i; ++j) {
                if (arr[i] > arr[j]) {
                    res = Math.max(res, dp[j]);
                }
            }
            //加上arr[i]
            dp[i] = res + 1;
            //找到最大长度
            maxLength = Math.max(maxLength, dp[i]);
        }
        int[] ans = new int[maxLength];
        for (int i = n - 1, j = maxLength; j > 0; --i) {
            //逆向找到第一个满足所需大小的数
            if (dp[i] == j) {
                //填入后继续寻找下一个数
                ans[--j] = arr[i];
            }
        }
        return ans;
    }

    /**
     * 非原创，百度一波总结下来的：
     * <p>
     * 一共需要两个辅助数组和一个辅助变量：
     * dp数组：用来存储位置i对应的最长子序列的长度
     * end数组：用来存储长度为i的子序列的最后一个元素的最小值
     * len：用来记录当前找到的最长子序列的长度
     * <p>
     * 举个例子
     * [3,2,5,8,6,7]
     * end数组：
     * i=0: 3	长度为1的子序列为：3
     * end=[3]
     * i=1:2<3 长度为1的子序列为：2(用2替换3,因为这是是最容易使子序列扩展为长度为2的子序列的值)
     * end=[2]
     * i=2:5>2	所以长度为1的子序列可以扩展成一个长度为2的子序列
     * 长度为1的子序列为：2
     * 长度为2的子序列为：2 5
     * end=[2 5]
     * i=3:8>5 所以长度为2的子序列可以扩展成一个长度为3的子序列
     * 长度为1的子序列为：2
     * 长度为2的子序列为：2 5
     * 长度为3的子序列为：2 5 8
     * end=[2 5 8]
     * i=4:6>5&&6<8 所以长度为2的子序列可以扩展成一个长度为3的子序列
     * 长度为1的子序列为：2
     * 长度为2的子序列为：2 5
     * 长度为3的子序列为：2 5 6(用6替换8,因为只是最容易使子序列扩展为长度为4的子序列的值)
     * end=[2 5 6]
     * i=5:7>6 所以长度为3的子序列可以扩展成一个长度为4的子序列
     * 长度为1的子序列为：2
     * 长度为2的子序列为：2 5
     * 长度为3的子序列为：2 5 6
     * 长度为4的子序列为：2 5 6 7
     * end=[2 5 6 7]
     * 笔记：我们用end[i]来存储长度为i+1的子序列的最后一个元素的最小值，因为这是最有希望使子序列扩展的值
     * 当a[x]>end[i]时，那么长度为i+1的子序列必定可以扩展成一个i+2的子序列，如果(old=end[i+1])>a[x]，那么就令
     * end[i+1]=a[x]，他的含义是只要a[y]>a[x]即使a[y]<old，那么长度为i+2的子序列也必然可以扩展为一个长度为i+3的子序列。
     * 所有最终结束时end数组为[2,5,6,7]即end[i]表示长度为(i+1)的子序列的最后一个元素值。
     * <p>
     * <p>
     * 遍历结束后也会生成    dp数组：
     * arr:[3,2,5,8,6,7]
     * dp :[1 1 2 3 3 4]
     * len=4
     * dp[i]表示到arr[i]为止最长的递增子序列，得到字典序最小的元素只需要倒过来遍历dp，依次输出最先遇到的长度为len,len-1,len-2....1的arr元素即可。
     * res用来存储字典序最小的最长子序列。
     * 即：    len=4  dp[5]==4 ==>res[3]=arr[5]=7
     * len=3  dp[4]==3 ==>res[3]=arr[4]=6
     * dp[3]==3  pass因为需要的是字典序最小的
     * len=2  dp[2]==2 ==>res[3]=arr[2]=5
     * len=1  dp[1]==1 ==>res[3]=arr[1]=2
     * dp[0]==1  pass因为需要的是字典序最小的
     * 结果：res=[2,5,6,7]
     * 笔记：设dp[x]==dp[y]&&x<y那么a[x]必定大于a[y]，因为如果a[x]<a[y]，那么dp[x]对应的子序列必定可以扩展为长度dp[x]+1的子序列即dp[y]=dp[x]+1>dp[x]，矛盾，所以a[y]<a[x]
     */
    public int[] LIS2(int[] arr) {

        return null;
    }

    /**
     *
     */
    public static void main(String[] args) {
        int[] arr = {1, 2, 8, 6, 4};
        int[] res1 = new Solution_NC91_最长上升子序列_3().LIS(arr);
        // 其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4）
        // [1,2,4]
        System.out.println("res1 = " + Arrays.toString(res1));
    }

}



